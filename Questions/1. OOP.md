# Основы Объектно-Ориентированного Программирования (ООП)

### Что такое ООП?
ООП - это одна из парадигм (методологий, подходов) программирования, основанная на принципах, предполагающих написание программного кода в виде классов и их объектов, взаимодействующих друг с другом.

    Парадигма программирования - стиль написания (оформления) исходного кода компьютерной программы

### Какие парадигмы вы знаете?
 - императивная (англ. imperative — приказ), когда программа состоит из последовательности инструкций (машина Тьюринга, машинный код, язык ассемблера и тд), которые говорят, как нужно добиться результата;
 <br><br>_**Эта парадигма имеет подвиды:**_ 
     - [структурная](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) (код делится на [блоки](https://ru.wikipedia.org/wiki/%D0%91%D0%BB%D0%BE%D0%BA_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)))
     > В соответствии с данной методологией любая программа строится без использования оператора goto из трёх базовых управляющих структур: последовательность, ветвление, цикл; кроме того, используются подпрограммы. При этом разработка программы ведётся пошагово, методом «сверху вниз».;
     - [процедурная](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5).
 - декларативная - когда мы описывам проблему и необходимый результат, то есть что мы хотим получить (а не как!), а язык уже сам разбирается, как этого достичь (SQL, HTML).
 _**Эта парадигма имеет подвиды:**_
     - функциональная;
     - логическая. 
 - ООП 

### Что такое класс?
Класс - это модель некой предметной области (blueprint, шаблон, образец), описывающая ее состояния и реализующая полностью или частично ее поведение. Это образец по которому будет создан объект.

### Что такое объект?
Объект - это конкретная сущность предметной области, обладающая внутренним состоянием (fields, поля) и поведением (methods, методы), а также являющаяся экземпляром класса.

### Что такое состояние объекта?
Состояние объекта (state) - это значения, которые принимают его поля. Со сменой значения полей - меняется состояние объекта.

### Что такое поведение объекта?
Поведение объекта (behavior) - это набор его методов, которые изменяют состояние объекта.

### Назовите основные принципы ООП?
    О каком количестве принципов вы хотите услышать?
Раньше этих принципов было три: инкапсуляция, наследование, полиморфизм. Потом появился четвертый принцип - абстракция.

### Что такое абстракция?
Что бы понять, что такое абстракция в программировании, нужно для начала разобраться в ее философском значении.
    
**Абстракция** (лат. abstractio — отвлечение) — некое обобщение как результат абстрагирования.
    
**Абстрагирование** — это процесс "необращания внимания" (отвлечения, отбрасывания лишних) на несущественные свойства изучаемого предмета, на данном уровне абстракции, с целью выделения нужных.
    
**Результат абстрагирования** являются абстрактные понятия, например: цвет, кривизна, красота и т. д.
    
**Уровень абстракции** — это степень отвлеченности (состояние, условие, ситуация), подразумевающее, что на данном этапе какие-то свойства (признакие)необходимо выделить, а какие-то пропустить.

В зависимости от целей и задач, можно рассуждать об одном и том же объекте на разных уровнях абстракции.

**Абстракция в программировании** — это реализация некой части программного кода, которая в зависимости от уровня абстракции отражает представление программиста об программируемом объекте(классе).

**Абстракция** - это выделение общих характеристик объекта и выстраивание иерархии наследования, основанной на этих первичных, общих, базовых свойствах абстрактного класса.

Программирование на уровне абстракции в Java — это написание кода с использованием абстрактных классов и интерфейсов, когда не берется во внимание реализация деталей, а выделяются лишь какие-то общие признаки, отличающие один класс от другого.

### Что такое инкапсуляция?
   **Инкапсуляция (encapsulation)** - это механизм языка, позволяющий ограничить прямой доступ к полям и методам класса извне (другим классам), с целью запретить им бесконтрольную модификацию состояния объекта или вызов методов, который также могут изменит его состояние.
   
   Изменять напрямую состояние объекта должен сам объект. Другие объекты должны осуществлять это только через его методы (геттеры, сеттеры).
   
   Сокрытие реализации уменьшает число ошибок в программе. Более того сокрытие внутренней кухни класса позволяет изменять реализацию скрытых методов без опасения, что это отразится на пользователях класса.
   
   Также инкапсуляция заставляет пользователя играть по правилам, показывая ему только необходимые методы и скрывая не нужные.
   
   Также инкапсуляция отделяет изменяемую часть класса от постоянной. Данное свойство полезно, т.к. позволяет безболезненно для пользователя менять код скрытых методов без каких-либо для него проблем, т.к. сигнатуры публичных методов, которые ему доступны, не меняются, а изменяются только приватные методы.
   
   Цель инкапсуляции — уйти от зависимости внешнего интерфейса класса(то , что могут использовать другие классы) от реализации. Чтобы малейшее изменение в классе не влекло за собой изменение внешнего поведения класса.

### Что такое наследование?
**Наследование (англ. inheritance)** — принцип, позволяющий создавать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью, что способствует уменьшению повторяемости кода, т.е. имеет место быть его переиспользование (англ. code reuse).

Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом.

   Совокупность всех классов, связанных между собой отношением наследования  образуют иерархию классов (англ. class hierarchy).
   
   При наследовании производному классу не всегда подходят реализации методов класса-предка, следовательно эти методы нужно переопределить, т.е. заместить новой реализацией старую.
   
   При этом доступ из методов класса наследника к приватным полям класса-предка напрямую запрещен. Для этого есть геттеры и сеттеры.
   
   Для обозначения наследования в java служит слово extends.
   
   Т.е. наследование позволяет взять готовый класс, "клонировать" его в новый класс-потомок, т.е. получить весь функционал класса-предка, а затем расширить его, добавив новые методы и поля.
   
   Так или иначе, но наследование всегда используется при создании любого класса, пусть и в не явном виде, т.к. любой класс в Java автоматически становится производным от суперкласса Object. Таким образом мы получаем доступ ко всем полям и методам классов предков.

Отношение "является" служит признаком наследования. Каждый руководитель является работником.

Для того что бы определить стоит ли применять наследование нужно для предка и предполагаемого производного класса попробовать установить отношение "является". Каждый руководитель является работником? Да. Работник <- руководитель

Чем дальше вверх по иерархии наследования, тем более универсальными и абстрактными становятся классы. Такие классы становятся основой для других классов, а не как классы, позволяющие создавать другие объекты.

Абстрактные методы представляют собой прототипы методов, реализованных в подклассах.

Можно создавать переменные ссылочного типа абстрактного класса, но такие переменные должны ссылаться не на абстрактный класс. Person p = new Student();

### Что такое полиморфизм?
Полиморфизм (греч. polymorphism — многообразие форм) - это свойство системы, позволяющее использовать объекты с общим интерфейсом или классом без информации о типе и внутренней структуре объекта.
 
 Это способность функции обрабатывать данные разных типов.
 
 Это позволяет писать код, независящий от конкретных типов, находящихся в одной иерархии типов по отношению друг к другу.
 
 Полиморфизм также называют динамическим связыванием, или поздним связыванием, или связыванием во время выполнения.

По простому: способность переменной ссылаться на объекты (вызывать нужные методы), имеющие разные типы. При этом происходит автоматический выбор нужного метода в зависимости от типа объекта. Данный механизм называется - динамическое связывание.

*Злоупотребление полиморфизмом может ухудшить архитектуру приложения. Вместо него можно использовать композицию, т.к. этот механизм более гибок, так как позволяет динамически выбирать тип, тогда как наследование требует, чтобы точный тип был известен уже на стадии компиляции.*

Что такое связывание?
Связывание (binding) - присоединение вызова метода к телу метода. Если связывание происходит во время компиляции - раннее связывание (early binding). Из-за раннего связывания компилятор не знает, какой метод вызывать, если есть ссылка на базовый класс, например в качестве аргумента метода, а передается в него класс-потомок, а таких потомков может быть много. И что делать? Для этого и существует позднее связывание (late binding), которое выполняется во время выполнения программы. Его также называют динамическим (dynamic) или связыванием на стадии выполнения (runtime binding). При позднем связывании определяется фактический тип объекта для вызова именно его метода. Позднее связывание не работат для методов, объявленных, как final, private(?), static(?).

Связывание всех методов в Java осуществляется полиморфно, через позднее связывание - это значит, что мы можем писать код для базового класса, который будет работать во всех производных классах от него.

Shape s = new Circle(); - Тут нет ошибки, т.к. Окружность является, благодаря наследованию, Фигурой, а это уже восходящее преобразование.
s.draw(); - будет вызван метода не базового класса (Фигура), а Окружности благодаря позднему связыванию (полиморфизм).

private методы не наследуются, а значит создание метода в классе наследнике с именем аналогичным методу класса предка, но с модификатором доступа private - создаст совершенно новый метод и компилятор не предупредит об этом. Аннотация поможет(?)

Статические методы не поддерживают полиморфного поведения, т.к. они существуют на уровне класса, а не на уровне отдельных объектов

Порядок инициализации объектов при наследовании:
-память, выделенная под новый объект, заполняется двоичными нулями
- в начале идет подъем до корня иерархии, а потом сверху вниз вызываются конструкторы один за другим вплоть до класса, конструируемого объекта.
- инициализируются поля класса в порядке их записи
-вызывается тело конструктора нужного объекта
Это делается для того, что бы быть уверенным, что все поля базовых классов проинициализированы, т.к. они доступны в нужном объекте, который имеет к ним доступ.

Начиная с Java SE5 появилась конвариантность возвращаемых типов. Это значит, что переопределенный метода класса-наследника может вернуть тип, отличный от типа такого же метода базового класса.

Что такое восходящее преобразование типов (upcasting)
Это когда, например метод в качестве параметра типа базового класса принимает тип класса наследника. Но это разумно, т.к. класс наследник является разновидностью класса предка. Данный факт позволяет преобразовывать ссылку на объект наследника в ссылку на объект предка. Восходящим оно называется потому, что стрелки наследования идут снизу вверх, более того корень иерархии всегда вверху. А сама диаграмма разрастается сверху вниз. Данное преобразование безопасно, т.к. это по сутипереход от конкретного типа к более общему, что часто ведет к потере методов, но не приобретению.

Преобразования можно делать и в обратном порядке - это называется нисходящее преобразование (downcasting). Но при этом может возникнуто проблема (?)

Интерпритация ссылки на объект как ссылки на базовый тип называется восходящим преобразованием. Это значит, что мы можем работать с объектом, как с его собственным типом, так и с базовым.

RTTI (runtime type identification, динамическое определение типов) - это проверка типа во время выполнения программы при нисходящем преобразовании. Т.к. мы можем осуществить приведение типа к такому типу у каоторого, например нет вызываемого при этом метода. Значит будет ошибка - ClassCastException. (Эккель, стр 260)


Типы отношений между классами

Что такое агрегация?

(«has-a», aggregation, объединение)
Агрегация применяется когда один класс должен быть контейнером других классов. Причем время существования содержащихся классов никак не зависит от времени существования класса контейнера. Например Студент входит в Группу любителей физики. Встречается, когда один класс является контейнером и коллекцией других. Class A has a list of B (Класс А содержит список Б). Т.е. в классе А есть поле List типа B. У учителя есть студенты. Учитель без студентов существует. ромбик всегда находится со стороны целого, а простая линия со стороны составной части. Разница между композицией и агрегацией заключается в том, что в случае композиции целое явно контролирует время жизни своей составной части (часть не существует без целого), а в случае агрегации целое хоть и содержит свою составную часть, время их жизни не связано (например, составная часть передается через параметры конструктора).

Различие между этими двумя видами ассоциации состоит в том, что композиция может быть частью одного и только одного целого, в то время как агрегация может быть частью нескольких объектов.

В отличие от отношения композиции, здесь профессора остаются жить после разрушения факультета, тогда как факультеты без университета погибают. Агрегация — отношение «часть-целое» между двумя равноправными объектами, когда один объект (контейнер) имеет ссылку на другой объект. Оба объекта могут существовать независимо: если контейнер будет уничтожен, то его содержимое — нет.
![image](https://user-images.githubusercontent.com/29703461/30761806-4ee00712-9fe8-11e7-8166-77b026e056d4.png)



### Что такое композиция?
Композиция — еще более «жесткое отношение, когда объект не только является частью другого объекта, но и вообще не может принадлежат еще кому-то. Например Машина и Двигатель. Хотя двигатель может быть и без машины, но он вряд ли сможет быть в двух или трех машинах одновременно. В отличии от студента, который может входить и в другие группы тоже. Такие описания всегда несколько условны, но тем не менее. Класс A состоит из списка B и не может существовать без наличия у него хотя бы одного объекта B. Машина состоит из деталей. Машины без деталей не существует. В Java как таковой композиции нет (?). Она нужна больше для С++ для сборки мусора. В java композицию просто игнорируют, считая все агрегацией. Композиция - это когда между моделируемыми объектами явно прослеживается отношение "часть - целое" (has-a - содержит).
Например, моделируя автомобиль, естественно считать, что двигатель - это часть автомобиля. Программируя эту модель, Вы выразите это в том, что объект класса Engine станет членом класса Auto.
Композиции обычно противопоставляют агрегацию и ассоциацию. Агрегация похожа на композицию в том, что это тоже отношение вида часть-целое, однако между объектами нет отношения владения. Например, "группа студентов" - студент часть группы, но студент может существовать и вне группы. То есть деструктор группы не должен "убивать" объектов-студентов. Ассоциация выражает любое отношение между объектами, которые могут вызывать методы друг друга.

Композиция и наследование позволяют помещать подобъекты внутрь нового класса (при композиции это происходит явно, а при наследовании опосредованно). В чем же разница между ними и когда используют тот или иной способ?

### В чем преимущество ООП?
Преимущество в более понятном представлении структуры кода, основанной на сущностях предметной области, взятых из реального мира с использованием принципов ООП, делающих разработку более гибкой, легко сопровождаемой и более естественной для человека. Что позволяет переиспользовать ранее написанный код.

Объектно-ориентированный подход обладает такими преимуществами, как:

уменьшение сложности программного обеспечения;
повышение надежности программного обеспечения;
обеспечение возможности модификации отдельных компонентов программного обеспечения без изменения остальных его компонентов;
обеспечение возможности повторного использования отдельных компонентов программного обеспечения.