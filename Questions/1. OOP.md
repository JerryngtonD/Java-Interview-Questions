# Основы Объектно-Ориентированного Программирования (ООП)

### Что такое ООП?
ООП - это одна из парадигм (методологий, подходов) программирования, основанная на принципах, предполагающих написание программного кода в виде классов и их объектов, взаимодействующих друг с другом.

    Парадигма программирования - это стиль написания (оформления) исходного кода компьютерной программы
    
   ООП возникло в результате развития идеологии процедурного программирования, где данные и подпрограммы (процедуры, функции), обрабатывающие их, формально не были связаны друг с другом, что при больших размерах программного кода приводило к проблемам понимания его работы и запутывало разработчиков.
   
   Но в ООП пошли дальше и решили эту проблему путем организации кода в виде классов, которые имеют уникальные имена, данные и некую функциональность, способную взаимодействовать с этими данными. Т.е. код стал более структурированным.
    
   > В первую очередь концепция объектно ориентированного программирования — это попытка изобразить программу в том виде, в котором человек видит и понимает окружающий мир.
   
   > Весь мир мыслит объектами. Мы сидим на стульях, пьем кофе из чашек, ездим на машинах и тд. Все мы существуем в мире объектов и живем среди них. Да и мы сами являемся объектом.
   
   > Но при этом следует понять, что ООП нужно программисту, чтобы контролировать сложность разработки. А не для того, чтобы всегда и везде «отражать объекты реального мира», как это пишут в книгах для начинающих.
   
    Хотят тут стоит оговориться, что зачастую простые объекты в какой-то мере все же являются отражением объектов реального мира

### Какие парадигмы вы знаете?
 - [императивная](https://ru.wikipedia.org/wiki/%D0%98%D0%BC%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) (англ. imperative — приказ), когда программа состоит из последовательности инструкций (машина Тьюринга, машинный код, язык ассемблера и тд), которые говорят, как(!) необходимо решить поставленную задачу;
    > одной из базовых концепций императивной парадигмы является переменная, хранящая своё значение и позволяющая менять его по мере выполнения алгоритма
 
    _**Эта парадигма имеет подвиды:**_
    - [структурная](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) (код делится на [блоки](https://ru.wikipedia.org/wiki/%D0%91%D0%BB%D0%BE%D0%BA_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)))
     > В соответствии с данной методологией любая программа строится без использования оператора goto из трёх базовых управляющих структур: следование, ветвление, цикл; кроме того, используются подпрограммы
     - [процедурная](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
     > Особенность таких языков программирования состоит в том, что задачи разбиваются на шаги (процедуры, подпрограммы) и решаются шаг за шагом.
 - [декларативная](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%BB%D0%B0%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) - это когда программа описывает то, что мы хотим получить (а не как!), а язык уже сам разбирается, как этого достичь (SQL, HTML).
 
    _**Эта парадигма имеет подвиды:**_
     - [функциональная](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
     > в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании).
     
     > Лямбда-исчисление являются основой для функционального программирования.
     
     > Функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы.
     
     > Первым функциональным языком был Лисп 
 - [ООП](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) 

### Что такое класс?
**Класс** - это составной (ссылочный) тип данных, являющийся прототипом (blueprint, шаблоном, моделью) объекта из какой-либо предметной области (сферы деятельности человека, но не обязательно), описывающий его состояние и реализующий его поведение. 

Также можно сказать, что класс - это образец по которому будет создан объект.

### Что такое объект?
**Объект** - это экземпляр какого-либо класса, отражающий конкретную сущность программируемой предметной области (не всегда!), и обладающий внутренним состоянием в виде полей (fields) и поведением (функционалом) в виде методов (methods).

### Что такое состояние объекта?
**Состояние объекта (state)** - это значения, которые принимают его поля. Со сменой значения полей - меняется состояние объекта.

### Что такое поведение объекта?
**Поведение объекта (behavior)** - это набор его методов, которые могут изменять состояние объекта либо выполнять иные функции.

### Назовите основные принципы ООП?
    О каком количестве принципов вы хотите услышать?
Раньше этих принципов было три: инкапсуляция, наследование, полиморфизм. Потом появился четвертый принцип - абстракция.

### Что такое абстракция?
Что бы понять, что такое абстракция в программировании, нужно для начала разобраться c ее философским значением.
    
**Абстракция** (лат. abstractio — отвлечение) — некое обобщение как результат абстрагирования.
    
**Абстрагирование** — это процесс "необращания внимания" (отбрасывания лишнего) на несущественные свойства изучаемого предмета, на данном уровне абстракции, с целью выделения нужных.
    
**Уровень абстракции** — это степень отвлеченности (условие, ситуация), подразумевающее, что на данном этапе какие-то свойства (признаки) объекта необходимо выделить, а какие-то проигнорировать.

![image](https://user-images.githubusercontent.com/29703461/30861862-c1886f4a-a2d4-11e7-94bb-e5cdf818d65e.png)

В зависимости от целей и задач, можно рассуждать об одном и том же объекте на разных уровнях абстракции.

**Программирование с помощью абстракции** — это написание кода с использованием абстрактных классов и интерфейсов, когда во внимание не берется реализация деталей, а выделяются лишь какие-то общие признаки на основании которых выстраивается иерархия наследования (уровни абстракции), основанная на базовых свойствах родительского класса.

### Что такое инкапсуляция?
   **Инкапсуляция** - это механизм языка, позволяющий ограничить прямой доступ к полям и методам класса извне (другим классам), с целью запретить бесконтрольную модификацию состояния объекта или вызов методов, которые также могут изменить его состояние.
   
 Для реализации этого механизма защиты в Java уществуют специальные синтаксические конструкции (модификаторы доступа), явно задающие область видимости каждого поля и метода класса: private, protected, package, public.
   
  Философия инкапсуляии состоит в том, что изменять напрямую состояние объекта должен сам объект. Другие объекты должны осуществлять это только через его методы (геттеры, сеттеры) с предварительной валидацией (если это необходимо).
   
 Также целью инкапсуляции является разрыв зависимости публичных методов класса (то, что могут использовать другие классы) от внутренних методов (скрытой части), реализующих функциональность, которая не должна быть видна другим класам.
 
 Это сделано для того чтобы малейшее изменение в классе (например изменение реализации способа хранения данных или их обработки и тд) не влекло за собой изменение внешнего поведения класса. Т.е. пользователи класса не должны страдать от его внутренних именений.
   
   **Достоинства:**<br> 
   - Сокрытие реализации позволяет сократить временные затраты на поиск ошибок, отладку приложения и более простое внесение изменений.
   
   - Также инкапсуляция заставляет пользователя играть по правилам, показывая ему только необходимые методы и скрывая не нужные.
   
   - инкапсуляция отделяет изменяемую часть класса от постоянной. Данное свойство полезно, т.к. позволяет безболезненно для пользователя менять код скрытых методов без каких-либо для него проблем, т.к. сигнатуры публичных методов, которые ему доступны, не меняются, а изменяются только скрытые (приватные) методы.
   
  **Недостатки:**
  - необходимо писать дополнительный код в виде гетеров и сеттеров
  - ...

### Что такое наследование?
**Наследование (англ. inheritance)** — принцип, позволяющий создавать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом.

Общий смысл наследования зключается в том, что если несколько классов имеют сходное поведение, то нет смысла дублировать их описание (писать с нуля), лучше выделить у них общие признаки и объединить их в общем для них родительском классе. При этом в описании самих классов оставить только различающиеся элементы (методы, поля) либо переопределить имеющиеся новой реализацией.

   Для обозначения наследования в Java служит слово extends.
   
   > Так или иначе, но наследование всегда используется при создании любого класса, пусть и в не явном виде, т.к. любой класс в Java автоматически становится производным от суперкласса Object. Таким образом мы получаем доступ ко всем полям и методам этого класса.
   
   Чем дальше вверх по иерархии наследования, тем более универсальными и абстрактными становятся классы. Такие классы становятся основой для других классов. И, как правило, запрещается создавать их экземпляры.
   
**Ограничения**

   - При наследовании доступ из методов класса наследника к приватным полям класса-предка напрямую запрещен. Для этого есть геттеры и сеттеры.
   
   - приватные поля и методы не наследуются
   
   - ...
   
   **Достоинства**
   -  способствует уменьшению повторяемости кода, т.е. имеет место быть его переиспользование (англ. code reuse).

   - ускоряет разработку. тк наследование позволяет взять готовый класс, "клонировать" его в новый класс-потомок, т.е. получить весь функционал класса-предка, а затем расширить его, добавив новые методы и поля.
   
   - ...
   
   **Недостатки**
   
   - Большое значение имеет правильное построение иерархии классов. Т.к на поздних этапах разработки, когда иерархия классов построена и на её основе разработано большое количество кода, оказывается трудно или даже невозможно внести какие-либо изменения в код базовых классов иерархии.
   
   - при внесении изменений в базовые классы - классы наследники об этом могут ничего не знать.
   
   - ...

**Когда нужно применять наследование**

Для того что бы определить стоит ли применять наследование нужно для предка и предполагаемого производного класса попробовать установить отношение "является".

Отношение "является" служит признаком наследования.
    
    Пример: Каждый Руководитель является Работником.

### Что такое полиморфизм?
**Полиморфизм (многообразие форм)** - это свойство системы, позволяющее использовать объекты с общим интерфейсом или классом без информации о типе и внутренней структуре объекта.
 
 Это способность функции обрабатывать данные разных типов.
 
 полиморфизм — возможность единообразно обрабатывать объекты с различной реализацией при условии наличия общего интерфейса.
 
Это означает, что можно создать общий интерфейс для группы близких по смыслу действий.

Преимуществом полиморфизма является то, что он помогает снижать сложность программ, разрешая использование одного интерфейса для единого класса действий. Выбор конкретного действия, в зависимости от ситуации, возлагается на компилятор.
 
 По простому: способность переменной ссылаться на объекты (вызывать нужные методы), имеющие разные типы. При этом происходит автоматический выбор нужного метода в зависимости от типа объекта. Данный механизм называется - динамическое связывание.
 
 Достоинства
 
 - Универсальность кода. 
 - ускорение разработки, т.к. полиморфизм позволяет писать код, независящий от конкретных типов, находящихся в одной иерархии типов по отношению друг к другу. А это значит, что не нужно для каждого типа из этой иерархии писать дублирующий код.
 
 Полиморфизм также называют динамическим связыванием, или поздним связыванием, или связыванием во время выполнения.

*Злоупотребление полиморфизмом может ухудшить архитектуру приложения. Вместо него можно использовать композицию, т.к. этот механизм более гибок, так как позволяет динамически выбирать тип, тогда как наследование требует, чтобы точный тип был известен уже на стадии компиляции.*

### Что такое связывание?

Связывание (binding) - присоединение вызова метода к телу метода. (?)

#### Что такое раннее связывание?
Если связывание происходит во время компиляции - раннее связывание (early binding). 

Из-за раннего связывания компилятор не знает, какой метод вызывать, если есть ссылка на базовый класс, например в качестве аргумента метода, а передается в него класс-потомок, а таких потомков может быть много. И что делать? Для этого и существует позднее связывание (late binding), которое выполняется во время выполнения программы. Его также называют динамическим (dynamic) или связыванием на стадии выполнения (runtime binding). При позднем связывании определяется фактический тип объекта для вызова именно его метода. 

Позднее связывание не работат для методов, объявленных, как final, private(?), static(?).

Связывание всех методов в Java осуществляется полиморфно, через позднее связывание - это значит, что мы можем писать код для базового класса, который будет работать во всех производных классах от него.

Пример:
Shape s = new Circle(); - Тут нет ошибки, т.к. Окружность является, благодаря наследованию, Фигурой, а это уже восходящее преобразование.

s.draw(); - будет вызван метода не базового класса (Фигура), а Окружности благодаря позднему связыванию (полиморфизм).

Что такое восходящее преобразование типов (upcasting)
Это когда, например метод в качестве параметра типа базового класса принимает тип класса наследника. Но это разумно, т.к. класс наследник является разновидностью класса предка. Данный факт позволяет преобразовывать ссылку на объект наследника в ссылку на объект предка. 

### Типы преобразования объектов

Восходящим оно называется потому, что стрелки наследования идут снизу вверх, более того корень иерархии всегда вверху. А сама диаграмма разрастается сверху вниз. Данное преобразование безопасно, т.к. это по сутипереход от конкретного типа к более общему, что часто ведет к потере методов, но не приобретению.

Преобразования можно делать и в обратном порядке - это называется нисходящее преобразование (downcasting). Но при этом может возникнуто проблема (?)

Интерпритация ссылки на объект как ссылки на базовый тип называется восходящим преобразованием. Это значит, что мы можем работать с объектом, как с его собственным типом, так и с базовым.

RTTI (runtime type identification, динамическое определение типов) - это проверка типа во время выполнения программы при нисходящем преобразовании. Т.к. мы можем осуществить приведение типа к такому типу у каоторого, например нет вызываемого при этом метода. Значит будет ошибка - ClassCastException. (Эккель, стр 260)


### Типы отношений между классами

Что такое агрегация?

(«has-a», aggregation, объединение)
Агрегация применяется когда один класс должен быть контейнером других классов. Причем время существования содержащихся классов никак не зависит от времени существования класса контейнера. Например Студент входит в Группу любителей физики. Встречается, когда один класс является контейнером и коллекцией других. Class A has a list of B (Класс А содержит список Б). Т.е. в классе А есть поле List типа B. У учителя есть студенты. Учитель без студентов существует. ромбик всегда находится со стороны целого, а простая линия со стороны составной части. Разница между композицией и агрегацией заключается в том, что в случае композиции целое явно контролирует время жизни своей составной части (часть не существует без целого), а в случае агрегации целое хоть и содержит свою составную часть, время их жизни не связано (например, составная часть передается через параметры конструктора).

Различие между этими двумя видами ассоциации состоит в том, что композиция может быть частью одного и только одного целого, в то время как агрегация может быть частью нескольких объектов.

В отличие от отношения композиции, здесь профессора остаются жить после разрушения факультета, тогда как факультеты без университета погибают. Агрегация — отношение «часть-целое» между двумя равноправными объектами, когда один объект (контейнер) имеет ссылку на другой объект. Оба объекта могут существовать независимо: если контейнер будет уничтожен, то его содержимое — нет.
![image](https://user-images.githubusercontent.com/29703461/30761806-4ee00712-9fe8-11e7-8166-77b026e056d4.png)

### Что такое композиция?
Композиция — еще более «жесткое отношение, когда объект не только является частью другого объекта, но и вообще не может принадлежат еще кому-то. Например Машина и Двигатель. Хотя двигатель может быть и без машины, но он вряд ли сможет быть в двух или трех машинах одновременно. В отличии от студента, который может входить и в другие группы тоже. Такие описания всегда несколько условны, но тем не менее. Класс A состоит из списка B и не может существовать без наличия у него хотя бы одного объекта B. Машина состоит из деталей. Машины без деталей не существует. В Java как таковой композиции нет (?). Она нужна больше для С++ для сборки мусора. В java композицию просто игнорируют, считая все агрегацией. Композиция - это когда между моделируемыми объектами явно прослеживается отношение "часть - целое" (has-a - содержит).
Например, моделируя автомобиль, естественно считать, что двигатель - это часть автомобиля. Программируя эту модель, Вы выразите это в том, что объект класса Engine станет членом класса Auto.
Композиции обычно противопоставляют агрегацию и ассоциацию. Агрегация похожа на композицию в том, что это тоже отношение вида часть-целое, однако между объектами нет отношения владения. Например, "группа студентов" - студент часть группы, но студент может существовать и вне группы. То есть деструктор группы не должен "убивать" объектов-студентов. Ассоциация выражает любое отношение между объектами, которые могут вызывать методы друг друга.

Композиция и наследование позволяют помещать подобъекты внутрь нового класса (при композиции это происходит явно, а при наследовании опосредованно). В чем же разница между ними и когда используют тот или иной способ?

### В чем преимущество ООП?
Преимущество в более понятном представлении структуры кода, основанной на сущностях предметной области, взятых из реального мира с использованием принципов ООП, делающих разработку более гибкой, легко сопровождаемой и более естественной для человека. Что позволяет переиспользовать ранее написанный код.

Объектно-ориентированный подход обладает такими преимуществами, как:

уменьшение сложности программного обеспечения;
повышение надежности программного обеспечения;
обеспечение возможности модификации отдельных компонентов программного обеспечения без изменения остальных его компонентов;
обеспечение возможности повторного использования отдельных компонентов программного обеспечения.


### Разное

private методы не наследуются, а значит создание метода в классе наследнике с именем аналогичным методу класса предка, но с модификатором доступа private - создаст совершенно новый метод и компилятор не предупредит об этом. Аннотация поможет(?)

Статические методы не поддерживают полиморфного поведения, т.к. они существуют на уровне класса, а не на уровне отдельных объектов

Порядок инициализации объектов при наследовании:
-память, выделенная под новый объект, заполняется двоичными нулями
- в начале идет подъем до корня иерархии, а потом сверху вниз вызываются конструкторы один за другим вплоть до класса, конструируемого объекта.
- инициализируются поля класса в порядке их записи
-вызывается тело конструктора нужного объекта
Это делается для того, что бы быть уверенным, что все поля базовых классов проинициализированы, т.к. они доступны в нужном объекте, который имеет к ним доступ.

Начиная с Java SE5 появилась конвариантность возвращаемых типов. Это значит, что переопределенный метода класса-наследника может вернуть тип, отличный от типа такого же метода базового класса.