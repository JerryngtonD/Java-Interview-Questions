Цель документа:
Описать простыми словами термины:
Схема взаимодействия между архитектурными слоями в web-приложении,
POJO, 
JavaBean, 
Entity, 
ValueObject,
DTO, 
DAO,
Repository
DAO vs Repository, 
REST.












Схема взаимодействия между архитектурными слоями в web-приложении

Из браузера
передаем http-запрос, который попадает в
web [controller, view, ui] layer
если - это rest-controller у которого есть внешнее API для сторонних приложений (внешних сервисов), то он принимает информацию снаружи через rest-запросы (по протоколу http).
Переданный в слой запрос (с параметрами) обрабатывается и результатом его работы являются какие-то сущности.
Далее этот слой обращается к
service layer
в котором находится и выполняется над сущностями некая бизнес-логика.
Если по ходу выполнения бизнес-логики данному слою нужны данные из базы (или иного места хранения), то он обращается к
dao [repository] layer
который в свою очередь обращается в базу (или другие источники хранения данных).
Данный слой работает с сущностями предметной области, т.е. сохраняет или достает из источника хранения данных entity, которые преобразуются в DTO (т.е. объекты, которые приближены по своей структуре к объектам бизнес-логики) и передаются вверх по цепочку слоев и в итоге отдаются наружу
domain [model, entity] layer
слой, описывающий сущности предметной области не содержащие какой-либо логики (только поля), т.е. классы, структура которых максимально приближена к формату таблиц, хранящихся в базе данных (или иного источника). Интерфейс ДАО содержит в параметрах методов данные сущности и использует их для сохранения в БД или получения их из нее.  
POJO (plain old java object, «старый добрый Java-объект») ⎼
это объект, который чаще всего представлен в виде набора полей и их сеттеров и геттеров без дополнительной нагрузки в виде:
Extend prespecified classes, as in
public class MealServlet extends HttpServlet { ...


Implement prespecified interfaces, as in
public class Entity implements EntityBean { ...


Contain prespecified annotations, as in (хотя статья на сайте Спринга допускает наличие аннотаций для POJO объектов)
@javax.persistence.Entity
public class Entity { ...

Термин POJO возник на платформе Java в качестве ответной реакции на появление платформы J2EE и ее широко распространившееся внедрение в приложениях, из-за чего, в частности, усложнился весь процесс разработки приложений. Мартин Фаулер с коллегами придумали данный термин для описания класса, свободного от «немого» кода, который требовался лишь для среды выполнения.

POJO был представлен в качестве альтернативы для JavaBeans и других «тяжелых» enterprise-конструкций, которые были популярны в 2000-х годах.

POJO - это класс, который не использует специальные возможности различных фреймворков (т.е. он не прибит гвоздями к архитектуре какой-либо библиотеки, а также не привязан к фреймворку, который его использует), таких как Spring, EJB и пр. Данные фреймворки появились позже и поэтому в названии присутствует слово "старый".
Пример:
	это POJO
class Meal {
    private int calories;

    Meal getCalories() {
        return this.calories;
    }


    void setCalories(int calories) {
        this.calories = calories;
	    }
		}

а это, нет 
class Calories {
    ...
    int calculateCalories() {
        return 42;
    }
}


Основной целью POJO было показать, что домен приложения может быть успешно смоделирован без использования JavaBeans. Более того, JavaBeans вообще не должны быть использованы для этой цели.

Таким образом, понятие POJO означает - использование настолько простых классов насколько возможно для моделирования предметной области. 

Резюмируя все вышесказанное, можно сказать, что POJO - этот класс, который ничего не делает и имеет только состояние.

JavaBean (не путать с Enterprise JavaBeans) ⎼
	это класс в языке Java, написанный по определённым правилам:
должен быть сериализуемыми (реализовывать интерфейс java.io.Serializable);
должен иметь конструктор без аргументов;
поля должны быть доступны через методы доступа get (аксессоры) и set (мутаторы);
все переменные экземпляра JavaBean должны быть закрытыми.
Пример:
public class Article implements java.io.Serializable {
   private static final long serialVersionUID = 1L;

   private int id;
   private String content;
   private boolean published;

   public Article() {
   }

   public int getId() {
      return id;
   }

   public void setId(int id) {
      this.id = id;
   }

   public String getContent() {
      return content;
   }

   public void setContent(String content) {
      this.content = content;
   }

   public boolean isPublished() {
      return published;
   }

   public void setPublished(boolean published) {
      this.published = published;
   }
}


Entity (сущность) ⎼
это данные, которые мы сохраняем в базу в формате базы данных, т.е. данные, приближенные к таблицам бд (типы и названия столбцов таблицы == типам и названиям полям в классе, взаимодействующему с конкретной таблицей). Хранятся в domain слое. 

является сущностью предметной области.

Сущности обладают неотъемлемой идентичностью, основанной на эквивалентности идентификаторов (id). Это значит, что  если данные в двух сущностях полностью одинаковы (за исключением Id поля), они не являются одной и той же сущностью.

сущности почти всегда изменяемы (мутабельны)


Value objects (Объект-Значение, термин из среды DDD) ⎼
это объекты без специальных методов, имеющие набор свойств со значениями, примитивными или тоже Value objects, которые проверяются на равенство исходя не из физической одинаковости (одинаковости ссылок на них), а из значений свойств.

Примером VO является любой класс, который реализует равенство через равенство содержащихся в нем данных.

Два объекта Дат считаются равными, если равны их значения дня, месяца и года.

В отличии от Entity не обладает идентичностью. На практике это означает, что объекты-значения не имеют поля-идентификатора и если два экземпляра одного объекта-значения обладают одинаковым набором атрибутов, мы можем считать их взаимозаменяемыми.

Объекты-значения должны быть неизменяемы в том смысле, что если нам необходимо изменить такой объект, мы создаем новый экземпляр на основе имеющегося вместо того чтобы изменять существующий.

Объект-значение всегда должен принадлежать одной или нескольким сущностям, он не может жить собственной жизнью.

Чтобы распознать объект-значение, мысленно замените его на integer.
Объекты-значения не должны иметь собственной таблицы в БД.
Пример: Integer, Money, Даты

В связи с этим проверки на равенство и хэш-операции данных объектов должны быть переопределены так, чтобы их выполнение основывалось, например, на величине денежной суммы и используемой валюты; на значениях дня, месяца, года и тд.


DTO (Data Transfer Object, объект переноса данных) ⎼
это паттерн, который предполагает использование отдельных классов для передачи данных (объектов с набором свойств и геттеров/сеттеров) между слоями. Данный класс, если его необходимо передавать по сети, должен быть сериализуемым (в XML, JSON и тд).
применяется для переноса данных между слоями в целях уменьшения количества вызовов.
это объект, который из низкоуровневых данных (entities) преобразуется в объект, используемый на слое Сервис и Контролер. Те, при обращении к Репозиторию из Сервиса, последний получает entity (набор табличных записей, которые возвращаются в результате выполнения SQL-запроса), преобразует его в DTO и отдает его на слой web. Их можно рассматривать как хранилище информации, единственная цель которого — передать эту информацию получателю.


Примером DTO является любой класс, который содержит только поля и свойства по извлечению этих данных.
DTO может собираться (состоять) из нескольких Entity, взятых из бд
 
DAO
Для доступа к данным удобно использовать какой-либо паттерн, позволяющий скрыть процесс их получения.

	Описание проблемы
	Способ доступа к данным бывает разным и зависит от источника данных. Способ доступа к базе данных очень зависит от типа хранилища (реляционные базы данных, объектно-ориентированные базы данных, однородные или «плоские» файлы и т.д.). Унифицированный API доступа к этим несовместимым системам отсутствует. А использование конкретного способа доступа создает зависимость между кодом приложения и кодом доступа к данным.
	Такая зависимость кода может сделать миграцию приложения от одного типа источника данных к другому трудной и громоздкой.
	Для решения вышеперечисленной проблемы необходимо использовать паттерн DAO (Data Access Object). Данный паттерн абстрагирует и инкапсулирует доступ к источнику данных, а также управляет соединением с источником данных для получения и записи данных.
	Т.е клиент по сути передает ответственность (делегирует) DAO за выполнение операций, связанных с взаимодействием с источником данных.
	JDBC API позволяет в приложениях использовать SQL-команды, являющиеся стандартным средством доступа к таблицам.
	DAO (data access object) — это объект, который предоставляет абстрактный интерфейс к какому-либо типу базы данных или или иному механизму хранения.
	Этот шаблон используется для связи программы, написанной на Java с реляционными базами данных через интерфейс JDBC.

В самом широком смысле, DAO — это класс, содержащий CRUD методы для конкретной сущности.
	 	 	
DAO полностью скрывает от клиента детали реализации взаимодействия с хранилищем данных. Поскольку при изменениях источника данных представляемый DAO интерфейс не изменяется, этот паттерн дает возможность DAO принимать различные схемы хранилищ без влияния на клиенты или бизнес-компоненты. По существу, DAO выполняет функцию адаптера между компонентом и источником данных.
	 	 	
паттерн DAO позволяет:
- отделить интерфейс(логика) от реализации: в начале определяем интерфейсы, а потом под них делаем любую реализацию в любом количестве, которую можно переключать в любое время, клиент ничего не заметит.
- клиенту не зависеть от конкретного источника данных - ему все равно, кто передает эти данные, он лишь дергает методы.
- внедрять большое количество реализаций интерфейсов.
	 	 	
Те ДАО - это промежуточный слой, который скрывает от клиента реализацию взаимодействия с разными хранилищами данных, способами и механизмами хранения, но при этом имея ко всем этим механизмам единые требования по функционалу в виде интерфейса.

Проблемы DAO
Большая часть людей представляет DAO некими вратами к базе данных и добавляет в него методы как только находит новый способ, которым они хотели бы общаться с базой данных. Поэтому нередко можно увидеть слишком раздутое DAO c большим количеством методов на все случаи жизни.
Чтобы уйти от этого, предлагается использовать паттерн Repository. В Repository вместо нескольких частных методов получения объекта или списка объектов используется один - query - которому передается объект (Specification), на основании которого строится запрос к базе. Объект Specification должен содержать информацию о том, по каким признакам фильтруются результаты запроса, и уметь превращаться в валидное условие для запроса. Это позволит (при достаточно развитой иерархии Specification) динамически создавать запросы любой сложности по любым критериям.


Repository (хранилище) ⎼
	паттерн, выполняющий роль коллекции объектов домена в оперативной памяти. Хранилище позволяет добавлять или удалять объекты, как будто мы работаем с обычными коллекциями. Тот факт, что объект домена на самом деле не находятся в хранилище, полностью скрыт от клиентских программ. Для них - это выглядит, как коллекция в памяти. Используется в Spring Data JPA

Разница между слоем dao и repository:
	DAO - это низкоуровневый слой, который работает с объектами базы
	repository - работает с объектами DTO
	Если Entity не переводятся в DTO, то два этих слоя сливаются и становятся одним и тем же


REST (Representational State Transfer — «передача состояния представления»)
REST-Controller - способ общения с внешними приложениями через установленный набор методов, за которые они могли бы дёргать наше приложение
REST определяет набор операций, которые, например User может выполнять над Meals
