###Что такое ООП?
ООП (Объектно-ориентированное программирование) - это одна из парадигм (методологий, подходов) программирования, основанная на принципах, предполагающих написание программного кода в виде классов и их объектов, взаимодействующих друг с другом.

###В чем преимущество ООЯП?
Преимущество в более понятном представлении структуры кода, основанной на сущностях предметной области, взятых из реального мира с использованием принципов ООП, делающих разработку более гибкой, легко сопровождаемой и более естественной для человека. Что позволяет переиспользовать ранее написанный код.

###Что такое класс?
Класс - это модель некой предметной области (шаблон, образец, blueprint), описывающая ее состояния и реализующая полностью или частично ее поведение. Это образец по которому будет создан объект.

###Что такое объект?
Объект - это конкретная сущность предметной области, обладающая внутренним состоянием (поля, fields) и поведением (методы, methods), а также являющаяся экземпляром класса.

###Что такое состояние объекта?

Состояние объекта - это значения, которые принимают его поля. Со сменой значения полей - меняется состояние объекта.

###Что такое поведение объекта?

Поведение объекта - это набор его методов, которые изменяют состояние объекта.


###Назовите основные принципы ООП?
О каком количестве принципов вы хотите услышать?
Раньше этих принципов было три: инкапсуляция, наследование, полиморфизм. Потом появился четвертый принцип - абстракция.

###Что такое инкапсуляция?
   Инкапсуляция - это механизм языка, позволяющий ограничить прямой доступ к полям и методам класса извне (другим классам), с целью запретить им бесконтрольную модификацию состояния объекта или вызов методов, который также могут изменит его состояние. Изменять напрямую состояние объекта должен сам объект. Другие объекты должны осуществлять это только через его методы (геттеры, сеттеры). Т.е каждая часть системы должна изменяться только с помощью ее методов. 
    Сокрытие реализации уменьшает число ошибок в программе. Более того сокрытие внутренней кухни класса позволяет изменять реализацию скрытых методов без опасения, что это отразится на пользователях класса.
    Также инкапсуляция заставляет пользователя играть по правилам, показывая ему только необходимые методы и скрывая не нужные.
    Также инкапсуляция отделяет изменяемую часть класса от постоянной. Данное свойство полезно, т.к. позволяет безболезненно для пользователя менять кода скрытых методов без каких-либо для него проблем, т.к. сигнатуры публичных методов, которые ему доступны, не меняются, а изменяются только приватные методы.

###Что такое наследование?
    Наследование (англ. inheritance) - принцип, позволяющий создавать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью, что способствует уменьшению повторяемости кода, т.е. имеет место быть его переиспользование (англ. code reuse). Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом.
    Совокупность всех классов, связанных между собой отношением наследования  образуют иерархию классов (англ. class hierarchy).
    Отношение "является" служит признаком наследования. Каждый руководитель является работником.
    При наследовании производному классу не всегда подходят реализации методов класса-предка, следовательно эти методы нужно переопределить, т.е. заместить новой реализацией старую.
    При этом доступ из методов класса наследника к приватным полям класса-предка напрямую запрещен. Для этого есть геттеры и сеттеры.
    Для обозначения наследования в java служит слово extends.
    Т.е. наследование позволяет взять готовый класс, "клонировать" его в новый класс-потомок, т.е. получить весь функционал класса-предка, а затем расширить его, добавив новые методы и поля.
    Так или иначе, но наследование всегда используется при создании любого класса, пусть и в не явном виде, т.к. любой класс в Java автоматически становится производным от суперкласса Object. Таким образом мы получаем доступ ко всем полям и методам классов предков.

    Для того что бы определить стоит ли применять наследование нужно для предка и предполагаемого производного класса попробовать установить отношение "является". Каждый руководитель является работником? Да. Работник <- руководитель

Чем дальше вверх по иерархии наследования, тем более универсальными и абстрактными становятся классы. Такие классы становятся основой для других классов, а не как классы, позволяющие создавать другие объекты.

Абстрактные методы представляют собой прототипы методов, реализованных в подклассах.

Можно создавать переменные ссылочного типа абстрактного класса, но такие переменные должны ссылаться не на абстрактный класс. Person p = new Student();

###Что такое полиморфизм?
    Это способность функции обрабатывать данные разных типов.
    Полиморфизм (polymorphism) - это свойство системы, позволяющее использовать объекты с общим интерфейсом или классом без информации о типе и внутренней структуре объекта. Это позволяет писать код, независящий от конкретных типов, находящихся в одной иерархии типов по отношению друг к другу. Полиморфизм также называют динамическим связыванием, или поздним связыванием, или связыванием во время выполнения.

    По простому: способность переменной ссылаться на объекты (вызывать нужные методы), имеющие разные типы. При этом происходит автоматический выбор нужного метода в зависимости от типа объекта. Данный механизм называется - динамическое связывание.

###Что такое связывание?

Связывание (binding) - присоединение вызова метода к телу метода. Если связывание происходит во время компиляции - раннее связывание (early binding). Из-за раннего связывания компилятор не знает, какой метод вызывать, если есть ссылка на базовый класс, например в качестве аргумента метода, а передается в него класс-потомок, а таких потомков может быть много. И что делать? Для этого и существует позднее связывание (late binding), которое выполняется во время выполнения программы. Его также называют динамическим (dynamic) или связыванием на стадии выполнения (runtime binding). При позднем связывании определяется фактический тип объекта для вызова именно его метода. Позднее связывание не работат для методов, объявленных, как final, private(?), static(?).

Связывание всех методов в Java осуществляется полиморфно, через позднее связывание - это значит, что мы можем писать код для базового класса, который будет работать во всех производных классах от него.

Shape s = new Circle(); - Тут нет ошибки, т.к. Окружность является, благодаря наследованию, Фигурой, а это уже восходящее преобразование.
s.draw(); - будет вызван метода не базового класса (Фигура), а Окружности благодаря позднему связыванию (полиморфизм).

private методы не наследуются, а значит создание метода в классе наследнике с именем аналогичным методу класса предка, но с модификатором доступа private - создаст совершенно новый метод и компилятор не предупредит об этом. Аннотация поможет(?)

Статические методы не поддерживают полиморфного поведения, т.к. они существуют на уровне класса, а не на уровне отдельных объектов

###Порядок инициализации объектов при наследовании:
-память, выделенная под новый объект, заполняется двоичными нулями
- в начале идет подъем до корня иерархии, а потом сверху вниз вызываются конструкторы один за другим вплоть до класса, конструируемого объекта.
- инициализируются поля класса в порядке их записи
-вызывается тело конструктора нужного объекта
Это делается для того, что бы быть уверенным, что все поля базовых классов проинициализированы, т.к. они доступны в нужном объекте, который имеет к ним доступ.

Начиная с Java SE5 появилась конвариантность возвращаемых типов. Это значит, что переопределенный метода класса-наследника может вернуть тип, отличный от типа такого же метода базового класса.

