# Основы Объектно-Ориентированного Программирования (ООП)

### Что такое ООП?
ООП — это одна из парадигм (методологий, подходов) программирования, основанная на принципах, предполагающих написание программного кода в виде классов и их объектов, взаимодействующих друг с другом.

    Парадигма программирования — это стиль написания (оформления) исходного кода компьютерной программы
    
   ООП возникло в результате развития идеологии процедурного программирования, где данные и подпрограммы (процедуры, функции), обрабатывающие их, формально не были связаны друг с другом, что при больших размерах программного кода приводило к проблемам понимания его работы и запутывало разработчиков.
   
   Но в ООП пошли дальше и решили эту проблему путем организации кода в виде классов, которые имеют уникальные имена, данные и некую функциональность, способную взаимодействовать с этими данными. Т.е. код стал более структурированным.
    
   > В первую очередь концепция объектно ориентированного программирования — это попытка изобразить программу в том виде, в котором человек видит и понимает окружающий мир.
   
   > Весь мир мыслит объектами. Мы сидим на стульях, пьем кофе из чашек, ездим на машинах и тд. Все мы существуем в мире объектов и живем среди них. Да и мы сами являемся объектом.
   
   > Следует понимать, что ООП нужно программисту, чтобы контролировать сложность разработки. А не для того, чтобы всегда и везде «отражать объекты реального мира», как это пишут в книгах для начинающих.
   
    Хотя тут стоит оговориться, что зачастую простые объекты в какой-то мере все же являются отражением объектов реального мира, но не всегда

## Какие парадигмы вы знаете?
 - [императивная](https://ru.wikipedia.org/wiki/%D0%98%D0%BC%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) (англ. imperative — приказ), когда программа состоит из последовательности инструкций (машина Тьюринга, машинный код, язык ассемблера и тд), которые говорят, как(!) необходимо решить поставленную задачу;
    > одной из базовых концепций императивной парадигмы является переменная, хранящая своё значение и позволяющая менять его по мере выполнения алгоритма.
 
    _**Эта парадигма имеет подвиды:**_
    - [структурная](https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) (код делится на [блоки](https://ru.wikipedia.org/wiki/%D0%91%D0%BB%D0%BE%D0%BA_(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)))
     > в соответствии с данной методологией любая программа строится без использования оператора goto из трёх базовых управляющих структур: следование, ветвление, цикл; кроме того, используются подпрограммы.
     - [процедурная](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
     > особенность таких языков программирования состоит в том, что задачи разбиваются на шаги (процедуры, подпрограммы) и решаются шаг за шагом.
 - [декларативная](https://ru.wikipedia.org/wiki/%D0%94%D0%B5%D0%BA%D0%BB%D0%B0%D1%80%D0%B0%D1%82%D0%B8%D0%B2%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) — это когда программа описывает то, что мы хотим получить (а не как!), а язык уже сам разбирается, как этого достичь (SQL, HTML).
 
    _**Эта парадигма имеет подвиды:**_
     - [функциональная](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%BE%D0%BD%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
     > в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании).
     
     > лямбда-исчисления являются основой для функционального программирования.
     
     > функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы.
     
     > Первым функциональным языком был Лисп 
 - [ООП](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE%D1%80%D0%B8%D0%B5%D0%BD%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5) 

### Что такое класс?
**Класс** — это составной (ссылочный) тип данных, являющийся прототипом (blueprint, шаблоном, моделью) объекта из какой-либо предметной области (сферы деятельности человека, но не обязательно), описывающий его состояние и реализующий его поведение. 

Также можно сказать, что класс — это образец по которому будет создан объект.

### Что такое объект?
**Объект** — это экземпляр какого-либо класса (расположенного в памяти), отражающий конкретную сущность программируемой предметной области (не всегда!), и обладающий внутренним состоянием в виде полей (fields) и поведением (функционалом) в виде методов (methods).

> Термин объект в программном обеспечении впервые был введен в языке Simula-67 и применялся для моделирования реальности. Но в полной мере ОО парадигма была полностью реализована в языке Smalltalk-80

### Что такое инстанциирование?

**Инстанцирование** (англ. instantiation) — создание экземпляра класса.

### Что такое инициализация объекта?

**Инициализация** (англ. initialization) — присвоение начальных значений полям объекта.

### Что такое время жизни объекта?

**Время жизни объекта** — время с момента создания объекта (с помощью конструктора) и до его уничтожения (с помощью garbage collector).

### Что такое состояние объекта?
**Состояние объекта (state)** — это значения, которые принимают его поля. Со сменой значения полей — меняется состояние объекта.

### Что такое поведение объекта?
**Поведение объекта (behavior)** — это набор его методов, которые могут изменять состояние объекта либо выполнять иные функции.

## Назовите основные принципы ООП?
    О каком количестве принципов вы хотите услышать?
Раньше этих принципов было три: инкапсуляция, наследование, полиморфизм. Потом появился четвертый принцип — абстракция.

### Что такое абстракция?
Что бы понять, что такое абстракция в программировании, нужно для начала разобраться с ее философским значением.
    
**Абстракция** (лат. abstractio — отвлечение) — некое обобщение как результат абстрагирования.
    
**Абстрагирование** — это процесс "необращания внимания" (отбрасывания лишнего) на несущественные свойства изучаемого предмета, на данном уровне абстракции, и выделения нужных.
    
**Уровень абстракции** — это степень отвлеченности (условие, ситуация), подразумевающее, что на данном этапе какие-то свойства (признаки) объекта необходимо выделить, а какие-то проигнорировать.

![image](https://user-images.githubusercontent.com/29703461/30861862-c1886f4a-a2d4-11e7-94bb-e5cdf818d65e.png)

В зависимости от целей и задач, можно рассуждать об одном и том же объекте на разных уровнях абстракции.

**Программирование с помощью абстракции** — это написание кода с использованием абстрактных классов и интерфейсов, когда во внимание не берется реализация деталей, а выделяются лишь какие-то общие признаки на основании которых выстраивается иерархия наследования (уровни абстракции), основанная на базовых свойствах родительского класса.

### Что такое инкапсуляция?
   **Инкапсуляция** — это механизм языка, позволяющий ограничить прямой доступ к полям и методам класса извне (другим классам), с целью запретить бесконтрольную модификацию состояния объекта или вызов методов, которые также могут изменить его состояние.
   
 Для реализации этого механизма защиты в Java существуют специальные синтаксические конструкции (модификаторы доступа), явно задающие область видимости каждого поля и метода класса: private, protected, package, public.
   
  Философия инкапсуляции состоит в том, что изменять напрямую состояние объекта должен сам объект. Другие объекты должны осуществлять это только через его методы (геттеры, сеттеры) с предварительной валидацией (если это необходимо).
   
 Также целью инкапсуляции является разрыв зависимости публичных методов класса (то, что могут использовать другие классы) от внутренних методов (скрытой части), реализующих функциональность, которая не должна быть видна другим классам.
 
    Если клиентский код не видит ничего, кроме публичных методов, то он не может зависеть от деталей реализации.
 
 Это сделано для того чтобы малейшее изменение в классе (например изменение реализации способа хранения данных или их обработки и тд) не влекло за собой изменения в работе класса-клиента. Т.е. пользователи класса не должны страдать от его внутренних изменений.
   
   **Достоинства:**
   
   - сокрытие реализации позволяет сократить временные затраты на поиск ошибок, отладку приложения и более простое внесение изменений;
   
   - также инкапсуляция заставляет пользователя играть по правилам, показывая ему только необходимые методы и скрывая не нужные;
   
   - инкапсуляция отделяет изменяемую часть класса от постоянной. Данное свойство полезно, т.к. позволяет безболезненно для пользователя менять код скрытых методов без каких-либо для него проблем, т.к. сигнатуры публичных методов, которые ему доступны, не меняются, а изменяются только скрытые (приватные) методы.
   
  **Недостатки:**
  - необходимо писать дополнительный код в виде геттеров и сеттеров, которые зачастую захламляют код;
  - ...

### Что такое наследование?
**Наследование (англ. inheritance)** — принцип, позволяющий создавать новый класс на основе уже существующего с частично или полностью заимствующейся функциональностью.

Класс, от которого производится наследование, называется базовым, родительским или суперклассом. Новый класс — потомком, наследником, дочерним или производным классом.

Общий смысл наследования заключается в том, что если несколько классов имеют сходное поведение, то нет смысла дублировать их описание (писать с нуля), лучше выделить у них общие признаки и объединить их в общем для них родительском классе. При этом в описании самих классов оставить только различающиеся элементы (методы, поля) либо переопределить имеющиеся новой реализацией.

![image](https://user-images.githubusercontent.com/29703461/30919809-27e4fdd6-a3ab-11e7-8517-e5261a93b532.png)


   Для обозначения наследования в Java служит слово extends.
   
   > так или иначе, но наследование всегда используется при создании любого класса, пусть и в не явном виде, т.к. любой класс в Java автоматически становится производным от суперкласса Object. Таким образом мы получаем доступ ко всем полям и методам этого класса.
   
   Чем дальше вверх по иерархии наследования, тем более универсальными и абстрактными становятся классы. Такие классы становятся основой для других классов. И, как правило, запрещается создавать их экземпляры.
   
   **В Java есть два вида наследования:**
   
   - наследование классов: каждый  наследник может иметь только одного родителя;
   - наследование  интерфейсов: интерфейс может иметь сколько угодно родителей.
   
   **Порядок инициализации объектов при наследовании**
   - память, выделенная под новый объект, заполняется двоичными нулями;
   
   - в начале идет подъем до корня иерархии, а потом сверху вниз вызываются конструкторы один за другим вплоть до класса, конструируемого объекта;
   
   - инициализируются поля класса в порядке их записи;
   
   - вызывается тело конструктора нужного объекта.
   
   Это делается для того, что бы быть уверенным, что все поля базовых классов проинициализированы, т.к. они доступны в нужном объекте, который имеет к ним доступ.
   
**Ограничения**

   - при наследовании доступ из методов класса наследника к приватным полям класса-предка напрямую запрещен. Для этого есть геттеры и сеттеры;
   
   - private методы не наследуются, а значит создание метода в классе наследнике с именем аналогичным методу класса предка, но с модификатором доступа private — создаст совершенно новый метод и компилятор не предупредит об этом. Аннотация поможет
   
   - ...
   
   **Достоинства**
   -  способствует уменьшению повторяемости кода, т.е. имеет место быть его переиспользование (англ. code reuse);

   - ускоряет разработку. тк наследование позволяет взять готовый класс, "клонировать" его в новый класс-потомок, т.е. получить весь функционал класса-предка, а затем расширить его, добавив новые методы и поля;
   
   - ...
   
   **Недостатки**
   
   - большое значение имеет правильное построение иерархии классов. Т.к на поздних этапах разработки, когда иерархия классов построена и на её основе разработано большое количество кода, оказывается трудно или даже невозможно внести какие-либо изменения в код базовых классов иерархии;
   
   - при внесении изменений в базовые классы — классы наследники об этом могут ничего не знать;
   
   - данный механизм требует, чтобы точный тип объекта был известен уже на стадии компиляции, что делает код, зависящим от реализации;
   
   - подкласс зависит от реализации родительского класса, что делает код сильно связанным.
   
   > вместо наследования можно использовать композицию / агрегацию, т.к. этот механизм более гибок, так как позволяет динамически выбирать тип.
   
   - ...

**Когда нужно применять наследование**

Для того что бы определить стоит ли применять наследование нужно для предка и предполагаемого производного класса попробовать установить отношение "является" ("is a").

Отношение "является" служит признаком наследования.
    
    Пример: Каждый Руководитель является Работником.

Наследование применяют для описания объектов, незначительно отличающихся друг от друга

При наследовании в классе-потомке должна добавляться функциональность, отличающаяся от существующей в классе-предке. Если в наследнике часть функциональности убирается, то это является поводом задуматься о необходимости в данной ситуации наследования.

### Что такое полиморфизм?
**Полиморфизм (многообразие форм)** — возможность единообразно обрабатывать объекты с различной реализацией при условии наличия у них общего интерфейса или класса.

![image](https://user-images.githubusercontent.com/29703461/30919897-599d28e4-a3ab-11e7-847c-bcad05d47ef1.png)

 Это способность функции обрабатывать данные разных типов.
 
 По-простому: способность переменной вызывать нужные методы у объектов, имеющие разные типы (но находящиеся в одной иерархии). При этом происходит автоматический выбор нужного метода в зависимости от типа объекта. 
 
 Данный механизм называется — динамическим связыванием или поздним связыванием, или связыванием во время выполнения (а не во время компиляции!).
 
 **Ограничения**
 - Статические методы не поддерживают полиморфного поведения, т.к. они существуют на уровне класса, а не на уровне отдельных объектов
 
 **Достоинства**
 
 - универсальность кода;
 
 - ускорение разработки, т.к. полиморфизм позволяет писать код, независящий от конкретных типов, находящихся в одной иерархии типов по отношению друг к другу. А это значит, что не нужно для каждого типа из этой иерархии писать дублирующий код;
 
 - снижение сложности программ, т.к. разрешая использование одного интерфейса для единого класса действий. При этом выбор конкретного действия, в зависимости от типа, возлагается на компилятор.
 
 **Недостатки**
 
 - ...

### Что такое связывание?

**Связывание (binding)** — присоединение вызова метода к телу метода. (непонятное определение!!!)

### Что такое раннее связывание?
**Раннее связывание (early binding)** — это связывание, происходящее во время компиляции. 

При раннем связывании тип объекта уже должен быть известен. Но так бывает не всегда, если имеет место быть иерархия наследования или общий интерфейс. 

Например, если есть ссылка на базовый класс, например в качестве аргумента метода, а передается в него класс-потомок, а таких потомков может быть много. Тут компилятор сошел бы с ума, т.к не знал бы методы какого класса вызывать. Но для разрешения этой проблемы существовал другой вид связывания.

### Что такое позднее связывание?
 
 **Позднее связывание (late binding)** — это связывание, которое выполняется во время выполнения программы. Его также называют динамическим (dynamic) или связыванием на стадии выполнения (runtime binding). При позднем связывании определяется фактический тип объекта для вызова именно его метода. 

**Ограничение**

 - позднее связывание не работает для методов, объявленных, как final, private(?), static(?).

Связывание всех методов в Java осуществляется полиморфно, через позднее связывание — это значит, что мы можем писать код для базового класса, который будет работать во всех производных классах от него.

**Пример:**

    Shape s = new Circle(); 
    s.draw();
 Тут нет ошибки, т.к. Окружность является, благодаря наследованию, Фигурой, а это уже восходящее преобразование.

s.draw(); — будет вызван метод не базового класса (Shape), а предка (Circle) благодаря позднему связыванию и полиморфизму.

### Что такое восходящее преобразование типов
**Восходящее преобразование (upcasting)** — это когда, например метод в качестве параметра типа базового класса принимает тип класса наследника. Но это разумно, т.к. класс наследник является разновидностью класса предка. Данный факт позволяет преобразовывать ссылку на объект наследника в ссылку на объект предка. 

Восходящим оно называется потому, что стрелки наследования идут снизу вверх, более того корень иерархии всегда вверху. Данное преобразование безопасно, т.к. это по сути переход от конкретного типа к более общему, что часто ведет к потере методов, но не приобретению.

Преобразования можно делать и в обратном порядке — это называется **нисходящее преобразование (downcasting)**.

## Типы отношений между классами

Прежде, чем дать определения отношениям между классами, хотелось бы внести некое разъяснение, которое поможет в понимании тонкостей данной терминологии. Речь пойдет о двух видах отношений — агрегации и композиции.

> если один объект состоит из других объектов (поля класса имеют ссылочный тип), которые создаются внутри этого объекта-контейнера и при этом время жизни "частей" зависит от времени жизни целого (умирает контейнер — погибают и его составляющий), то это называется композицией.

> но если после смерти объекта-контейнера его части остаются жить (не удаляюся GC, тк на них ссылаются в другом месте программы), то это уже агрегация.

Если еще проще, то вся разница между агрегацией и композицией состоит в том, каким образом инициализируются поля в классе-контейнере и как эта инициализация влияет на время их жизни после смерти основного класса.

С точки зрения программирования - это выгляит так: если в классе-контейнере в теле конструктора (без передачи аргумента) или прямо в поле взять и присвоить ссылку на объект, то логично предположить, что со смертью основного класса умрут и все его внутренние объекты т.е. тут жесткая взаимозависимость — это композиция.

А, если создать объект, а потом передал его в качестве аргумента в сеттер или в конструктор, а потом присвоить его полю, то со смертью класса — все созданные таким образом объекты будут жить и дальше — это агрегация. 

А теперь приведу примеры того, что пишут в интернете, возможно, кому-то они покажутся проще.

### Что такое агрегация?

Агрегация (aggregation; «has-a» — есть, имеет, содержит) применяется когда один класс должен быть контейнером для других классов. Причем время существования содержащихся в нем классов (полей) никак не зависит от времени существования класса контейнера. 

Агрегация — отношение «часть-целое» между двумя равноправными объектами, когда один объект (контейнер) имеет ссылку на другой объект. Оба объекта могут существовать независимо: если контейнер будет уничтожен, то его содержимое — нет.

Данный вид связи на UML-диаграмме обозначается в виде линии с незакрашенным ромбиком (ромбик всегда находится со стороны целого, а простая линия со стороны составной части). 

![image](https://user-images.githubusercontent.com/29703461/30761806-4ee00712-9fe8-11e7-8166-77b026e056d4.png)

### Что такое композиция?
Композиция — еще более жесткое отношение, когда объект не только является частью другого объекта, но и вообще не может принадлежать еще кому-то. Когда объект уничтожается, объекты, составляющие его, также уничтожаются.

Данный вид связи на UML-диаграмме обозначается в виде линии с закрашенным ромбиком (ромбик всегда находится со стороны целого, а простая линия со стороны составной части).

**Разница между агрегацией и композицией**

> разница между композицией и агрегацией заключается в том, что в случае композиции целое явно контролирует время жизни своей составной части (часть не существует без целого), а в случае агрегации целое хоть и содержит свою составную часть, время их жизни не связано.

> различие между этими двумя видами ассоциации состоит в том, что композиция может быть частью одного и только одного целого, в то время как агрегация может быть частью нескольких объектов.

**Пример этих видов связи из реального мира**
 
Возьмем отвертку. Если отвертка цельная, т.е. ручка и насадка намертво связаны друг с другом, то это композиция. Если же насадка съемная и может существовать без ручки или же использоваться с другой ручкой, то это агрегация.

Композицию часть предпочитают наследованию 

 > один из хороших критериев выбора между композицией и наследованием - спросить себя, собираетесь ли вы впоследствии проводить восходящее преобразование от производного класса к базовому.
 
 **Достоинства**
  - контроль видимости;
  - реализация может быть заменена во время выполнения (run-time);
  - слабая связанность, так как класс-интерфейс не зависит от реализации.

### В чем преимущество ООП?
- более понятное представление структуры кода, основанное на сущностях предметной области, взятых из реального мира, что делает разработку более естественной для человека;

- уменьшение сложности программного обеспечения;

- повышение надежности программного обеспечения;

- обеспечение возможности модификации отдельных компонентов программного обеспечения без изменения остальных его компонентов;

- обеспечение возможности повторного использования отдельных компонентов программного обеспечения.

### Какие есть недостатки у ООП?